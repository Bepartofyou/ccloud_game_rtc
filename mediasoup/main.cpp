/*
libboost_chrono-vc140-mt-gd-1_60.lib
libboost_date_time-vc140-mt-gd-1_60.lib
libboost_filesystem-vc140-mt-gd-1_60.lib
libboost_locale-vc140-mt-gd-1_60.lib
libboost_regex-vc140-mt-gd-1_60.lib
libboost_system-vc140-mt-gd-1_60.lib
libboost_thread-vc140-mt-gd-1_60.lib
libprotobuf-lited.lib
libprotobufd.lib
libprotocd.lib
..\libsdptransform\Debug\sdptransform.lib
obj/webrtc.lib
advapi32.lib
comdlg32.lib
dbghelp.lib
dnsapi.lib
gdi32.lib
msimg32.lib
odbc32.lib
odbccp32.lib
oleaut32.lib
shell32.lib
shlwapi.lib
user32.lib
usp10.lib
uuid.lib
version.lib
wininet.lib
winmm.lib
winspool.lib
ws2_32.lib
delayimp.lib
kernel32.lib
ole32.lib
crypt32.lib
iphlpapi.lib
secur32.lib
dmoguids.lib
wmcodecdspuuid.lib
amstrmid.lib
msdmo.lib
strmiids.lib
d3d11.lib
dxgi.lib
obj/api/create_peerconnection_factory.lib
obj/api/libjingle_peerconnection_api.lib
obj/media/rtc_media_base.lib
obj/p2p/rtc_p2p.lib
obj/api/audio_codecs/builtin_audio_decoder_factory.lib
obj/api/audio_codecs/builtin_audio_encoder_factory.lib
obj/api/video_codecs/builtin_video_decoder_factory.lib
obj/api/video_codecs/builtin_video_encoder_factory.lib
obj/media/rtc_audio_video.lib
obj/modules/audio_processing/audio_processing.lib
obj/modules/video_capture/video_capture_module.lib
obj/pc/peerconnection.lib
obj/rtc_base/rtc_base.lib
obj/rtc_base/experiments/field_trial_parser.lib
obj/api/transport/network_control.lib
obj/third_party/boringssl/boringssl.lib
obj/third_party/boringssl/boringssl_asm.lib
obj/logging/rtc_event_log_impl_base.lib
obj/logging/rtc_event_log_impl_encoder.lib
obj/modules/audio_coding/audio_network_adaptor_config.lib
obj/modules/remote_bitrate_estimator/remote_bitrate_estimator.lib
obj/common_video/common_video.lib
win_clang_x64/obj/third_party/libyuv/libyuv_internal.lib
obj/third_party/libjpeg_turbo/libjpeg.lib
obj/third_party/libjpeg_turbo/simd.lib
obj/third_party/libjpeg_turbo/simd_asm.lib
obj/system_wrappers/system_wrappers.lib
obj/rtc_base/rtc_numerics.lib
obj/logging/rtc_event_log2_proto.lib
obj/third_party/protobuf/protobuf_lite.lib
obj/logging/rtc_event_log_proto.lib
obj/modules/audio_coding/audio_network_adaptor.lib
obj/common_audio/common_audio.lib
obj/common_audio/common_audio_sse2.lib
obj/modules/audio_coding/ana_config_proto.lib
obj/modules/audio_coding/ana_debug_dump_proto.lib
obj/media/rtc_constants.lib
obj/modules/utility/utility.lib
obj/modules/audio_processing/config.lib
obj/modules/audio_processing/audio_buffer.lib
obj/audio/utility/audio_frame_operations.lib
obj/modules/audio_processing/aec3/aec3.lib
obj/modules/audio_processing/vad/vad.lib
obj/third_party/pffft/pffft.lib
obj/p2p/libstunprober.lib
obj/rtc_base/weak_ptr.lib
obj/api/video/builtin_video_bitrate_allocator_factory.lib
obj/modules/video_coding/encoded_frame.lib
obj/rtc_base/experiments/alr_experiment.lib
obj/rtc_base/experiments/rtt_mult_experiment.lib
obj/modules/rtp_rtcp/rtp_rtcp.lib
obj/rtc_base/experiments/quality_scaling_experiment.lib
obj/rtc_base/experiments/rate_control_settings.lib
obj/modules/video_coding/webrtc_vp9_helpers.lib
obj/api/video_codecs/rtc_software_fallback_wrappers.lib
obj/call/call.lib
obj/modules/bitrate_controller/bitrate_controller.lib
obj/modules/pacing/pacing.lib
obj/api/transport/goog_cc.lib
obj/modules/congestion_controller/goog_cc/goog_cc.lib
obj/modules/congestion_controller/congestion_controller.lib
obj/modules/congestion_controller/transport_feedback.lib
obj/modules/congestion_controller/rtp/transport_feedback.lib
obj/audio/audio.lib
obj/modules/audio_coding/audio_coding.lib
obj/modules/audio_coding/neteq.lib
obj/modules/audio_coding/webrtc_cng.lib
obj/modules/audio_coding/audio_encoder_cng.lib
obj/rtc_base/experiments/audio_allocation_settings.lib
obj/modules/video_coding/video_coding.lib
obj/modules/video_coding/packet.lib
obj/rtc_base/experiments/jitter_upper_bound_experiment.lib
obj/video/video.lib
obj/modules/video_coding/nack_module.lib
obj/modules/video_processing/video_processing.lib
obj/modules/video_processing/video_processing_sse2.lib
obj/rtc_base/experiments/keyframe_interval_settings_experiment.lib
obj/modules/audio_mixer/audio_mixer_impl.lib
obj/modules/audio_mixer/audio_frame_manipulator.lib
obj/pc/rtc_pc_base.lib
obj/media/rtc_data.lib
obj/third_party/usrsctp/usrsctp.lib
obj/third_party/libsrtp/libsrtp.lib
obj/rtc_base/experiments/normalize_simulcast_size_experiment.lib
obj/modules/audio_processing/audioproc_debug_proto.lib
obj/stats/rtc_stats.lib
obj/api/audio_codecs/L16/audio_decoder_L16.lib
obj/modules/audio_coding/pcm16b.lib
obj/modules/audio_coding/g711.lib
obj/modules/audio_coding/legacy_encoded_audio_frame.lib
obj/api/audio_codecs/g711/audio_decoder_g711.lib
obj/api/audio_codecs/g722/audio_decoder_g722.lib
obj/modules/audio_coding/g722.lib
obj/api/audio_codecs/isac/audio_decoder_isac_float.lib
obj/modules/audio_coding/isac.lib
obj/modules/audio_coding/isac_c.lib
obj/modules/audio_coding/isac_common.lib
obj/api/audio_codecs/ilbc/audio_decoder_ilbc.lib
obj/modules/audio_coding/ilbc.lib
obj/api/audio_codecs/opus/audio_decoder_multiopus.lib
obj/api/audio_codecs/opus/audio_encoder_opus_config.lib
obj/modules/audio_coding/webrtc_multiopus.lib
obj/third_party/opus/opus.lib
obj/modules/audio_coding/audio_coding_opus_common.lib
obj/api/audio_codecs/opus/audio_decoder_opus.lib
obj/modules/audio_coding/webrtc_opus.lib
obj/api/audio_codecs/L16/audio_encoder_L16.lib
obj/api/audio_codecs/g711/audio_encoder_g711.lib
obj/api/audio_codecs/g722/audio_encoder_g722.lib
obj/api/audio_codecs/isac/audio_encoder_isac_float.lib
obj/api/audio_codecs/ilbc/audio_encoder_ilbc.lib
obj/media/rtc_internal_video_codecs.lib
obj/media/rtc_encoder_simulcast_proxy.lib
obj/media/rtc_simulcast_encoder_adapter.lib
obj/modules/video_coding/webrtc_h264.lib
obj/modules/video_coding/webrtc_multiplex.lib
obj/modules/video_coding/webrtc_vp8.lib
obj/modules/video_coding/webrtc_vp8_temporal_layers.lib
obj/api/video_codecs/vp8_temporal_layers_factory.lib
obj/rtc_base/experiments/cpu_speed_experiment.lib
obj/third_party/libvpx/libvpx.lib
obj/third_party/libvpx/libvpx_yasm.lib
..\Debug\mediasoupclient.lib
*/
#include "Broadcaster.hpp"
#include "mediasoupclient.hpp"
//#include <cpr/cpr.h>
#include <csignal> // sigsuspend()
#include <cstdlib>
#include <iostream>
#include <string>
#include "httplib.h"
#include "cwebsocket_mgr.h"
#include "ccfg.h"
#include <WinUser.h>
#include <Windows.h>
#include "Broadcaster.hpp"
#include "cwebsocket_mgr.h"
#include "ccfg.h"
#include "httplib.h"
using json = nlohmann::json;
Broadcaster *broadcaster;
bool stoped = false;


void stop()
{
	webrtc::g_websocket_mgr.destroy();
	// Remove broadcaster from the server.
	broadcaster->Stop();
	RTC_LOG(LS_INFO) << "[INFO] leaving!";
	delete broadcaster;
	broadcaster = nullptr;
	stoped = true;
	//std::exit(signum);
}
void signalHandler(int signum)
{
	RTC_LOG(LS_INFO) << "[INFO] interrupt signal (" << signum << ") received";

	stop();
	
}




int  start()
{
	std::string ws_url = "ws://" + webrtc::g_cfg.get_string(webrtc::ECI_MediaSoup_Host) + ":" + std::to_string(webrtc::g_cfg.get_int32(webrtc::ECI_MediaSoup_Http_Port)) + "/?roomId=" + webrtc::g_cfg.get_string(webrtc::ECI_Room_Name) + "&peerId=" + webrtc::g_cfg.get_string(webrtc::ECI_Client_Name);//ws://127.0.0.1:8888/?roomId=chensong&peerId=xiqhlyrn", "http://127.0.0.1:8888")
	std::string origin = "http://" + webrtc::g_cfg.get_string(webrtc::ECI_MediaSoup_Host) + ":" + std::to_string(webrtc::g_cfg.get_int32(webrtc::ECI_MediaSoup_Http_Port));
	if (!webrtc::g_websocket_mgr.init(ws_url, origin))
	{
		RTC_LOG(LS_ERROR) << "weboscket connect failed !!! url = " << ws_url;
		return -1;
	}
	webrtc::g_websocket_mgr.start();


	if (webrtc::g_websocket_mgr.get_status() != webrtc::CWEBSOCKET_MESSAGE)
	{
		RTC_LOG(LS_ERROR) << "weboscket mgr status = " << webrtc::g_websocket_mgr.get_status() << "failed !!! ";
		return -1;
	}



	const char* envWebrtcDebug = std::getenv("WEBRTC_DEBUG");
	const char* envVerifySsl = std::getenv("VERIFY_SSL");
	const char * envServerUrl = origin.c_str();
	std::string room_name = webrtc::g_cfg.get_string(webrtc::ECI_Room_Name);
	const char * envRoomId = room_name.c_str();
	const char * envEnableAudio = "false";
	std::string client_name = webrtc::g_cfg.get_string(webrtc::ECI_Client_Name);
	const char * name = client_name.c_str();
	const char* envUseSimulcast = "false";
	if (envServerUrl == nullptr)
	{
		std::cerr << "[ERROR] missing 'SERVER_URL' environment variable" << std::endl;

		return 1;
	}

	if (envRoomId == nullptr)
	{
		std::cerr << "[ERROR] missing 'ROOM_ID' environment variable" << std::endl;

		return 1;
	}

	std::string baseUrl = envServerUrl;
	baseUrl.append("/rooms/").append(envRoomId);

	bool enableAudio = true;

	if (envEnableAudio && std::string(envEnableAudio) == "false")
		enableAudio = false;

	bool useSimulcast = true;

	if (envUseSimulcast && std::string(envUseSimulcast) == "false")
		useSimulcast = false;

	bool verifySsl = true;
	if (envVerifySsl && std::string(envVerifySsl) == "false")
		verifySsl = false;




	std::cout << "[INFO] welcome to mediasoup broadcaster app!\n" << std::endl;



	std::string host = webrtc::g_cfg.get_string(webrtc::ECI_MediaSoup_Host);
	httplib::Client cli(host, webrtc::g_cfg.get_uint32(webrtc::ECI_MediaSoup_Http_Port));
	std::string url = baseUrl;
	auto res = cli.Get(url.c_str());
	if (!res)
	{
		RTC_LOG(LS_ERROR) << "[ERROR]Stop";

		//	promise.set_exception(std::make_exception_ptr(res->body));
		return -1;// promise.get_future();
	}
	if (res->status != 200)
	{
		RTC_LOG(LS_ERROR) << "[ERROR] Stop"
			<< " [status code:" << res->status << ", body:\"" << res->body << "\"]";

		//promise.set_exception(std::make_exception_ptr(res->body));
		return -1;// promise.get_future();
	}

	RTC_LOG(INFO) << __FUNCTION__ << __LINE__ << "[" << res->body << "]";
	auto response = nlohmann::json::parse(res->body);

	broadcaster = new Broadcaster();


	broadcaster->Start(baseUrl, enableAudio, useSimulcast, response, verifySsl, name);

	std::cout << "[INFO] press Ctrl+C or Cmd+C to leave..." << std::endl;
	std::string new_url = url + "/AllDataProducers";
	std::set<std::string> dataProduceIds;
	while (!stoped)
	{
		//broadcaster.createDataConsumer();

		if (webrtc::g_websocket_mgr.get_status() != webrtc::CWEBSOCKET_MESSAGE)
		{
			RTC_LOG(LS_ERROR) << "websocket status = " << webrtc::g_websocket_mgr.get_status() << "failed !!!";
			break;
		}
		res = cli.Get(new_url.c_str());
		if (!res)
		{
			RTC_LOG(LS_ERROR) << "[ERROR]Stop";
			break;
			//	promise.set_exception(std::make_exception_ptr(res->body));
			//return -1;// promise.get_future();
		}
		if (res->status != 200)
		{
			RTC_LOG(LS_ERROR) << "[ERROR] Stop"
				<< " [status code:" << res->status << ", body:\"" << res->body << "\"]";
			break;
		}
		else
		{
			//RTC_LOG(INFO)  << __FUNCTION__ << __LINE__ <<"[" << res->body << "]" ;
			auto response = nlohmann::json::parse(res->body);

			if (response["peers"].is_array())
			{
				for (int i = 0; i < response["peers"].size(); ++i)
				{
					if (response["peers"][i]["displayName"] != "test")
					{
						auto iter = dataProduceIds.find(response["peers"][i]["displayName"]);
						if (iter != dataProduceIds.end())
						{
							continue;
						}
						std::string displayName = response["peers"][i]["displayName"];

						for (int j = 0; j < response["peers"][i]["dataProducers"].size(); ++j)
						{
							if ("chat" == response["peers"][i]["dataProducers"][j]["label"])
							{
								//dataProduceIds;
								//std::string id = response["peers"][i]["dataProducers"][j]["id"];
								std::string dataProducerId = response["peers"][i]["dataProducers"][j]["id"];
								//uint32_t streamId = response["peers"][i]["dataConsumers"][j]["sctpStreamParameters"]["streamId"];
								//json AppData = response["peers"][i]["dataConsumers"][j]["sctpStreamParameters"]["AppData"];;
								json body =
								{
									{ "dataProducerId", dataProducerId }
								};
								broadcaster->CreateDataConsumer(body);
								RTC_LOG(LS_INFO) << "  dataProducerId = " << dataProducerId;
								dataProduceIds.insert(displayName);
							}
						}
					}
				}
			}
		}
		std::this_thread::sleep_for(std::chrono::seconds(2));

	}
	stop();
	
}



int main(int argc, char* argv[])
{
	//while (1);
	
	signal(SIGINT, signalHandler);
	const char* config_filename = "client.cfg";
	if (argc > 1)
	{
		config_filename = argv[1];
	}
	bool init = webrtc::g_cfg.init(config_filename);
	if (!init)
	{
		RTC_LOG(LS_ERROR) << "config init failed !!!" << config_filename;
		return -1;
	}
	 

	auto logLevel = mediasoupclient::Logger::LogLevel::LOG_DEBUG;
	mediasoupclient::Logger::SetLogLevel(logLevel);
	mediasoupclient::Logger::SetDefaultHandler();

	// Initilize mediasoupclient.
	mediasoupclient::Initialize();



	

	start();
	return 0;
	
	
	std::thread push_thread;
	
	while (true)
	{
		RTC_LOG(LS_INFO) << "restart push client start ^_^ ";
		int64_t seconds = 100;
		
		if (push_thread.joinable())
		{
			push_thread.join();
		}
		stoped = false;
		RTC_LOG(LS_INFO) << " mediasoup thread start  ^_^ ";
		push_thread = std::thread(&start);
		/*std::thread([]()
		{
			RTC_LOG(LS_INFO) << " mediasoup thread start  ^_^ ";
			start();
			RTC_LOG(LS_INFO) << " mediasoup thread stop  ^_^ ";
		}).detach();*/
		while (seconds > 50)
		{
			--seconds;

			std::this_thread::sleep_for(std::chrono::seconds(1));
			printf("========seconds = %u\n", seconds);
		}
		stoped = true;
		 
		RTC_LOG(LS_INFO) << "restart push client stop  ^_^ ";
	}
	

	return 0;
}
